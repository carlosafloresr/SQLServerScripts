SET NOCOUNT OFF

DECLARE	@DOCNUMBER			Varchar(30),
		@RMDTYPAL			Smallint,
		@ApFromTrx_Source	Varchar(10),
		@CUSTNMBR			Varchar(15),
		@APTODCNM			Varchar(30),
		@APFRDCTY			Smallint,
		@ORTRXAMT			Numeric(10,2),
		@CURTRXAM			Numeric(10,2),
		@APPTOAMT			Numeric(10,2),
		@WROFAMNT			Numeric(10,2),
		@AppliedDate		Date,
		@APFRDCNM			Varchar(30),
		@App_Source			Varchar(10),
		@APFR_BACHNUMB		Varchar(30),
		@Sorter				Smallint,
		@ForDeletion		Bit,
		@RunningBalance		Numeric(10,2),
		@Summary			Numeric(10,2) = 0

DECLARE	@Transactions TABLE
		(ApFromTrx_Source	Varchar(10),
		CUSTNMBR			Varchar(15),
		APTODCNM			Varchar(30),
		APFRDCTY			Smallint,
		ORTRXAMT			Numeric(10,2),
		CURTRXAM			Numeric(10,2),
		APPTOAMT			Numeric(10,2),
		WROFAMNT			Numeric(10,2),
		AppliedDate			Date,
		APFRDCNM			Varchar(30),
		App_Source			Varchar(10),
		APFR_BACHNUMB		Varchar(30),
		Sorter				Smallint,
		ForDeletion			Bit,
		RunningBalance		Numeric(10,2))

DECLARE	@FinalTransactions	TABLE
		(ApFromTrx_Source	Varchar(10),
		CUSTNMBR			Varchar(15),
		APTODCNM			Varchar(30),
		APFRDCTY			Smallint,
		ORTRXAMT			Numeric(10,2),
		CURTRXAM			Numeric(10,2),
		APPTOAMT			Numeric(10,2),
		WROFAMNT			Numeric(10,2),
		AppliedDate			Date,
		APFRDCNM			Varchar(30),
		App_Source			Varchar(10),
		APFR_BACHNUMB		Varchar(30),
		Sorter				Smallint,
		ForDeletion			Bit,
		RunningBalance		Numeric(10,2))

-- FIND TRANSACTIONS WITH INVALID BALANCES
SELECT	TRANS.Location,
		TRANS.CUSTNMBR, 
		TRANS.DocNumbr, 
		TRANS.DocDate, 
		TRANS.RMDTYPAL, 
		TRANS.ORTRXAMT, 
		TRANS.CURTRXAM,  
		SUM(ALLTRX.DISAVTKN) [DiscTaken], 
		SUM(ALLTRX.[WROFAMNT]) [Writeoff], 
		SUM(ALLTRX.AppToAmt) [Apply Amt],
		ORTRXAMT - SUM(ALLTRX. DISAVTKN) - SUM(ALLTRX.[WROFAMNT]) - SUM(ALLTRX.AppToAmt) -  CURTRXAM [AppDiff],
		TRANS.CUSTNMBR + '-' + TRANS.DocNumbr + '-' + CAST((TRANS.RMDTYPAL) AS VarChar(2)) [Defect_Records]
INTO	##tmpTransactions
FROM	(
			SELECT	'OpenTrx' [Location],
					CUSTNMBR, 
					DocNumbr, 
					DocDate, 
					RMDTYPAL, 
					ORTRXAMT, 
					CURTRXAM  
			FROM	RM20101
			WHERE	VoidSTTS = 0
			UNION
			SELECT	'HistTrx',
					CUSTNMBR, 
					DocNumbr, 
					DocDate, 
					RMDTYPAL, 
					ORTRXAMT, 
					CURTRXAM  
			FROM	RM30101
			WHERE	VoidSTTS = 0
		) TRANS
		INNER JOIN (SELECT	DISTINCT CUSTNMBR, TRXSORCE, APFRDCNM, APFRDCTY, APTODCNM, APPTOAMT, DISAVTKN, WROFAMNT, Date1, GLPOSTDT 
					FROM	(
								SELECT	CUSTNMBR, 
										TRXSORCE, 
										APFRDCNM, 
										APFRDCTY, 
										APTODCNM, 
										APPTOAMT, 
										DISAVTKN, 
										WROFAMNT, 
										Date1, 
										GLPOSTDT 
								FROM	RM20201
								UNION ALL
								SELECT	CUSTNMBR, 
										TRXSORCE, 
										APFRDCNM, 
										APFRDCTY, 
										APTODCNM, 
										APPTOAMT, 
										DISAVTKN, 
										WROFAMNT, 
										Date1, 
										GLPOSTDT
								FROM	RM30201
							) BOTHTRX
					) ALLTRX ON TRANS.CUSTNMBR = ALLTRX.CUSTNMBR AND TRANS.DOCNUMBR = ALLTRX.APTODCNM
GROUP BY
		TRANS.Location,
		TRANS.CUSTNMBR, 
		TRANS.DocNumbr, 
		TRANS.DocDate, 
		TRANS.RMDTYPAL, 
		TRANS.ORTRXAMT, 
		TRANS.CURTRXAM
HAVING	ORTRXAMT - SUM(ALLTRX. DISAVTKN) - SUM(ALLTRX.[WROFAMNT]) - SUM(ALLTRX.AppToAmt) <>  CURTRXAM
ORDER BY TRANS.CUSTNMBR, TRANS.DOCNUMBR

-- SEARCH THE APPLIED TRANSACTIONS INFORMATION
DECLARE InvalidBalancesTrx CURSOR LOCAL KEYSET OPTIMISTIC FOR
SELECT	CUSTNMBR, 
		DocNumbr,
		ORTRXAMT,
		CURTRXAM,
		RMDTYPAL
FROM	##tmpTransactions

OPEN InvalidBalancesTrx 
FETCH FROM InvalidBalancesTrx INTO @CUSTNMBR, @DOCNUMBER, @ORTRXAMT, @CURTRXAM, @RMDTYPAL

WHILE @@FETCH_STATUS = 0 
BEGIN
	INSERT INTO @Transactions
	SELECT	CASE WHEN RM20101.DOCNUMBR IS Null THEN 'History' ELSE 'Open' END AS [ApFromTrx_Source],
			APO.CUSTNMBR,
			APO.APTODCNM,
			APO.APFRDCTY,
			@ORTRXAMT,
			@CURTRXAM,
			APO.APPTOAMT,
			APO.WROFAMNT,
			APO.DATE1 AS AppliedDate,
			APO.APFRDCNM,
			'Open' AS [App_Source],
			ISNULL(RM20101.BACHNUMB,RM30101.BACHNUMB) AS APFR_BACHNUMB,
			CASE WHEN APO.WROFAMNT <> 0 OR APO.APFRDCTY = 9 THEN 0 ELSE CASE WHEN ISNULL(RM20101.BACHNUMB,RM30101.BACHNUMB) LIKE '%BOX%' THEN 1 ELSE 2 END END AS Sorter,
			0, 0
	FROM	RM20201 APO
			LEFT JOIN RM20101 ON (APO.CUSTNMBR = RM20101.CUSTNMBR OR APO.CPRCSTNM = RM20101.CUSTNMBR) AND APO.APFRDCNM = RM20101.DocNumbr AND APO.APFRDCTY = RM20101.RMDTYPAL AND RM20101.VOIDSTTS = 0
			LEFT JOIN RM30101 ON (APO.CUSTNMBR = RM30101.CUSTNMBR OR APO.CPRCSTNM = RM30101.CUSTNMBR) AND APO.APFRDCNM = RM30101.DocNumbr AND APO.APFRDCTY = RM30101.RMDTYPAL AND RM30101.VOIDSTTS = 0
	WHERE	APO.CUSTNMBR = @CUSTNMBR
			AND APO.APTODCNM = @DOCNUMBER
			AND APO.APTODCTY = @RMDTYPAL
	UNION
	SELECT	CASE WHEN RM20101.DOCNUMBR IS Null THEN 'History' ELSE 'Open' END AS [ApFromTrx_Source],
			APO.CUSTNMBR,
			APO.APTODCNM,
			APO.APFRDCTY,
			@ORTRXAMT,
			@CURTRXAM,
			APO.APPTOAMT,
			APO.WROFAMNT,
			APO.DATE1 AS AppliedDate,
			APO.APFRDCNM,
			'History' AS [App_Source],
			ISNULL(RM20101.BACHNUMB,RM30101.BACHNUMB) AS APFR_BACHNUMB,
			CASE WHEN APO.WROFAMNT <> 0 OR APO.APFRDCTY = 9 THEN 0 ELSE CASE WHEN ISNULL(RM20101.BACHNUMB,RM30101.BACHNUMB) LIKE '%BOX%' THEN 1 ELSE 3 END END AS Sorter,
			0, 0
	FROM	RM30201 APO
			LEFT JOIN RM20101 ON (APO.CUSTNMBR = RM20101.CUSTNMBR OR APO.CPRCSTNM = RM20101.CUSTNMBR) AND APO.APFRDCNM = RM20101.DocNumbr AND APO.APFRDCTY = RM20101.RMDTYPAL AND RM20101.VOIDSTTS = 0
			LEFT JOIN RM30101 ON (APO.CUSTNMBR = RM30101.CUSTNMBR OR APO.CPRCSTNM = RM30101.CUSTNMBR) AND APO.APFRDCNM = RM30101.DocNumbr AND APO.APFRDCTY = RM30101.RMDTYPAL AND RM30101.VOIDSTTS = 0
	WHERE	APO.CUSTNMBR = @CUSTNMBR
			AND APO.APTODCNM = @DOCNUMBER
			AND APO.APTODCTY = @RMDTYPAL
	ORDER BY 13, APO.DATE1

	DECLARE APTransactions CURSOR LOCAL KEYSET OPTIMISTIC FOR
	SELECT	* 
	FROM	@Transactions

	SET @Summary = 0

	OPEN APTransactions 
	FETCH FROM APTransactions INTO @ApFromTrx_Source, @CUSTNMBR, @APTODCNM, @APFRDCTY, @ORTRXAMT, @CURTRXAM, @APPTOAMT, @WROFAMNT, 
									@AppliedDate, @APFRDCNM, @App_Source, @APFR_BACHNUMB, @Sorter, @ForDeletion, @RunningBalance

	-- IDENTIFY THE TRANSACTIONS TO BE REMOVED FROM THE DOCUMENT
	WHILE @@FETCH_STATUS = 0 
	BEGIN
		IF @Summary + @APPTOAMT + @WROFAMNT > @ORTRXAMT
			SET @ForDeletion = 1
		ELSE
		BEGIN
			SET @Summary = @Summary + @APPTOAMT + @WROFAMNT
			SET @ForDeletion = 0
		END

		UPDATE	@Transactions 
		SET		RunningBalance = @Summary, --CASE WHEN @ForDeletion = 1 THEN 0 ELSE @Summary END,
				ForDeletion = @ForDeletion --CASE WHEN @Summary > @ORTRXAMT AND @ORTRXAMT <> @APPTOAMT THEN 1 ELSE 0 END
		WHERE	CUSTNMBR = @CUSTNMBR
				AND APTODCNM = @APTODCNM
				AND APFRDCNM = @APFRDCNM
				AND App_Source = @App_Source

		FETCH FROM APTransactions INTO @ApFromTrx_Source, @CUSTNMBR, @APTODCNM, @APFRDCTY, @ORTRXAMT, @CURTRXAM, @APPTOAMT, @WROFAMNT, 
										@AppliedDate, @APFRDCNM, @App_Source, @APFR_BACHNUMB, @Sorter, @ForDeletion, @RunningBalance
	END
	
	CLOSE APTransactions
	DEALLOCATE APTransactions

	-- STORE THE TEMPORAL INFORMATION INTO THE FINAL TRANSACTIONS TABLE
	INSERT INTO @FinalTransactions
	SELECT	* 
	FROM	@Transactions

	DELETE	@Transactions
	FETCH FROM InvalidBalancesTrx INTO @CUSTNMBR, @DOCNUMBER, @ORTRXAMT, @CURTRXAM, @RMDTYPAL
END

SELECT	DB_NAME() AS Company, *, ROW_NUMBER() OVER (PARTITION BY CUSTNMBR, APTODCNM ORDER BY CUSTNMBR, APTODCNM) AS TransNumber
FROM	@FinalTransactions
ORDER BY
		CUSTNMBR,
		APTODCNM,
		Sorter,
		AppliedDate

DROP TABLE ##tmpTransactions